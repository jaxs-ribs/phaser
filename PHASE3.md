# PHASE 3: Long-Term Memory and Workflow Automation (Rust Edition)

This final core phase focuses on giving the agent long-term memory of conversations and automating common developer workflows like creating commits and pull requests within the Rust application.

## Task 3.1: Implement Conversation History

**Goal:** Create a persistent memory store for conversation history using SQLite.

**Crate Modules:** `src/orchestrator/memory.rs`

**Instructions:**

1.  Create an `orchestrator` module: make a `src/orchestrator` directory with a `mod.rs` file.
2.  Create `src/orchestrator/memory.rs`.
3.  Implement a `MemoryManager` struct.
4.  Use the `rusqlite` crate to connect to a database file at `memory.sqlite`.
5.  Implement the following methods:
    *   `new()`: Connects to the DB and creates a `conversations` table if it doesn't exist. The table should have columns like `id`, `timestamp`, `role` (user/assistant), and `content`.
    *   `add_message(role, content)`: Adds a new message to the history.
    *   `get_recent_history(limit)`: Retrieves the last `limit` messages.
6.  Add `rusqlite` to `Cargo.toml`.

**Acceptance Criteria:** A `MemoryManager` that can persist conversation history to an SQLite database and retrieve it.

---

## Task 3.2: Implement Git Client for PRs

**Goal:** Create a utility to interact with the local Git repository to stage changes and prepare summaries for pull requests.

**Crate Modules:** `src/utils/git_client.rs`

**Instructions:**

1.  Create a `utils` module: make a `src/utils` directory with a `mod.rs` file.
2.  Create `src/utils/git_client.rs`.
3.  Implement a `GitClient` struct.
4.  Use a crate like `git2-rs` for safe Git operations.
5.  Implement the following methods:
    *   `get_diff(staged=False)`: Returns the diff of the working directory or staged changes.
    *   `get_status()`: Returns a summary of the repository status.
    *   `add(files)`: Adds one or more files to the staging area.
    *   `commit(message)`: Creates a new commit with the given message.
6.  Add `git2` to `Cargo.toml`.

**Acceptance Criteria:** A `GitClient` struct that can inspect and manipulate the state of the Git repository.

---

## Task 3.3: Implement `tmux` Session Launcher

**Goal:** Create a convenience script to automate the setup of a standardized development environment using `tmux`.

**Directory:** `scripts/`

**File to Create:** `scripts/start_dev_session.sh`

**Instructions:**

1.  Create `scripts/start_dev_session.sh`.
2.  Write a shell script that uses `tmux` commands to:
    a.  Create a new `tmux` session named `project-x-dev`.
    b.  Split the window into multiple panes. For example:
        *   Pane 1 (60% height): For running `cargo run`.
        *   Pane 2 (40% height): For running `cargo watch -x test`.
    c.  The script can pre-fill some panes with initial commands.
3.  Make the script executable (`chmod +x`).
4.  Add `cargo-watch` to the development tools to be installed.

**Acceptance Criteria:** Running `./scripts/start_dev_session.sh` sets up a consistent and useful `tmux` layout for Rust development.

---

## Task 3.4: Integrate Memory and Git into Orchestrator

**Goal:** Modify the main orchestrator loop to use the new memory and Git utilities.

**Crate Modules:** `src/orchestrator/mod.rs` and `src/main.rs`

**Instructions:**

1.  The central orchestrator logic will reside in the `orchestrator` module.
2.  In `src/main.rs`, the main loop will call into the orchestrator.
3.  The orchestrator will:
    a.  Instantiate `MemoryManager` and `GitClient`.
    b.  **Memory Integration:** Before building a prompt, call `memory.get_recent_history()` to fetch context. After a turn, save the user query and LLM response using `memory.add_message()`.
    c.  **Git Integration:** Implement a command (e.g., triggered by a keyword in the user prompt) that uses the `GitClient` to `add` and `commit` changes with a message generated by the LLM.

**Acceptance Criteria:** The main application loop can maintain conversation context across sessions and can programmatically commit code changes based on user commands.

---

## Task 3.5: Write Tests

**Goal:** Add integration tests for the new memory and Git utilities.

**Directory:** `tests/`

**Files to Create:**
*   `tests/orchestrator.rs`
*   `tests/utils.rs`

**Instructions:**

1.  Create `tests/utils.rs`.
    *   For the `GitClient`, tests will be complex. It's best to test against a temporary, newly-initialized Git repository on the filesystem to ensure commands like add and commit work as expected.
2.  Create `tests/orchestrator.rs`.
    *   For the `MemoryManager`, use an in-memory SQLite database (`:memory:`) for testing. Test adding messages and retrieving history, ensuring data integrity.
3.  Add tests to the main orchestrator logic to verify that it correctly interacts with the `MemoryManager` and `GitClient`.

**Acceptance Criteria:** All new tests pass when running `cargo test`. 